/**********************************************************************************************************************
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *  File: MotTqCalcd.c
 *  SW-C Type:MotTqCalcd
 *  C/C++ source code generated on : Tue Mar 20 14:25:55 2018
   Code generated for Simulink model 'MotTqCalcd'.
 ***********************************************************************************************************************
   Tool Information
 *-----------------------------------------------------------------------------------------------------------------------
 * Simulink Coder version         : 8.13 (R2017b) 24-Jul-2017
 **********************************************************************************************************************
 * Copyright '2018' Nxtr
 * Nxtr Confidential
 *
 * Module File Name  : MotTqCalcd.c
 * Module Description: This component calculates motor torque estimate from measured Motor Currents or reference Motor Currents based on the Motor Control And Thermal Protection LOA Mode
 * Project           : CBD
 * Author            : vipin.d
 ***********************************************************************************************************************
 * Version Control:
 * %version:  		1 %
 * %derived_by:     dzvc93 %
 **********************************************************************************************************************
 * CHANGE LOG COPIED FROM SIMULINK MODEL
 *---------------------------------------
 * Change Log

   Ver 1.0.1
   Author :Vipin David (TataElxsi)
   Date : 14 Mar 2018
   Change Control:EA4#21805
   Description : Design updated for autocoding without any functionality change.


   Ver 1.0.0
   Author :Mansi Geet (KPIT)
   Date : 02 Feb 2018
   Change Control #:EA4#16544, EA4#17869
   Description : Initial version from Requirment baseline 1.1



 **********************************************************************************************************************/
/*********************File Level Rule Deviations*******************************/

/* MISRA-AGC Rule 16.10 [NXTRDEV 16.10.1]: There is no appropriate action to take on the return value for Rte_Read, Rte_Write */
/* MISRA-AGC Rule 19.1  [NXTRDEV 19.1.1]:  AUTOSAR requires deviation from this rule for Memory Mapping include statements */

/* MISRA-AGC Rule 8.1   [NXTRDEV 8.1.1] :  Deviation for autocode only, due to tools limitation.
   ‘_Init’ function does not have a declaration/prototype in autocode. This init function is generated by embedded coder and is not present in the Simulink model.
   This function is always empty and is not called */

/* MISRA-AGC Rule 8.10  [NXTRDEV 8.10.2]:  Deviation for autocode only, due to tools limitation.
   ‘_Init’ function is not defined as “static” even though no external linkage is required. This init function is generated by embedded coder and is not present in the Simulink model.
   This function is always empty and is not called */
#include "MotTqCalcd.h"
#define MotTqCalcd_START_SEC_CODE
#include "MotTqCalcd_MemMap.h"

/*
 * Check that imported macros with storage class "ImportedDefine" are defined
 */
#ifndef ARCHGLBPRM_HALFSQRT3_ULS_F32
#error The variable for the parameter "ARCHGLBPRM_HALFSQRT3_ULS_F32" is not defined
#endif

#ifndef FALSE
#error The variable for the parameter "FALSE" is not defined
#endif

#ifndef TRUE
#error The variable for the parameter "TRUE" is not defined
#endif

/* Exported data define */

/* Definition for custom storage class: Const_Local */
#define BIT0MASK_CNT_U08               ((uint8)(1U))
#define BIT1MASK_CNT_U08               ((uint8)(2U))
#define BIT2MASK_CNT_U08               ((uint8)(4U))
#define MOTTQESTIMDMAX_MOTNWTMTR_F32   ((float32)(15.0F))
#define MOTTQESTIMDMIN_MOTNWTMTR_F32   ((float32)(-15.0F))
#define RELNCTQCON_ULS_F32             ((float32)(0.375F))

/* Model step function for TID1 */
FUNC(void, MotTqCalcd_CODE) MotTqCalcdInit1(void) /* Sample time: [0.002s, 0.0s] */
{
  /* (no output/update code required) */
}

/* Model step function for TID2 */
FUNC(void, MotTqCalcd_CODE) MotTqCalcdPer1(void) /* Sample time: [0.002s, 0.0s] */
{
  /* local block i/o variables */
  float32 rtb_Merge;
  float32 tmpRead;
  float32 tmpRead_0;
  float32 tmpWrite;
  uint8 rtb_TmpSignalConversionAtMotAnd;
  float32 rtb_TmpSignalConversionAtMotI_e;
  float32 rtb_TmpSignalConversionAtMotInd;
  float32 rtb_TmpSignalConversionAtMotBac;
  boolean rtb_TmpSignalConversionAtMotA_0;
  boolean rtb_TmpSignalConversionAtMotA_1;
  boolean rtb_TmpSignalConversionAtMotA_2;

  /* RootInportFunctionCallGenerator: '<Root>/RootFcnCall_InsertedFor_call_MotTqCalcdPer1_at_outport_1' incorporates:
   *  SubSystem: '<S1>/MotTqCalcdPer1'
   */
  /* SignalConversion: '<S4>/TmpSignal ConversionAtMotAndThermProtnLoaModOutport1' incorporates:
   *  Inport: '<Root>/MotAndThermProtnLoaMod'
   */
  Rte_Read_MotAndThermProtnLoaMod_Val(&rtb_TmpSignalConversionAtMotAnd);

  /* SignalConversion: '<S4>/TmpSignal ConversionAtMotInduDaxEstimdOutport1' incorporates:
   *  Inport: '<Root>/MotInduDaxEstimd'
   */
  Rte_Read_MotInduDaxEstimd_Val(&rtb_TmpSignalConversionAtMotInd);

  /* SignalConversion: '<S4>/TmpSignal ConversionAtMotInduQaxEstimdOutport1' incorporates:
   *  Inport: '<Root>/MotInduQaxEstimd'
   */
  Rte_Read_MotInduQaxEstimd_Val(&rtb_TmpSignalConversionAtMotI_e);

  /* SignalConversion: '<S4>/TmpSignal ConversionAtMotBackEmfConEstimdOutport1' incorporates:
   *  Inport: '<Root>/MotBackEmfConEstimd'
   */
  Rte_Read_MotBackEmfConEstimd_Val(&rtb_TmpSignalConversionAtMotBac);

  /* Switch: '<S5>/Switch2' incorporates:
   *  Constant: '<S5>/Constant4'
   *  Constant: '<S5>/Constant5'
   *  Constant: '<S5>/Constant8'
   *  RelationalOperator: '<S5>/Relational Operator2'
   *  S-Function (sfix_bitop): '<S5>/Bitwise Operator2'
   */
  if ((rtb_TmpSignalConversionAtMotAnd & ((uint8)BIT2MASK_CNT_U08)) == ((uint8)
       BIT2MASK_CNT_U08))
  {
    rtb_TmpSignalConversionAtMotA_0 = ((boolean)TRUE);
  }
  else
  {
    rtb_TmpSignalConversionAtMotA_0 = ((boolean)FALSE);
  }

  /* End of Switch: '<S5>/Switch2' */

  /* Switch: '<S5>/Switch' incorporates:
   *  Constant: '<S5>/Constant'
   *  Constant: '<S5>/Constant1'
   *  Constant: '<S5>/Constant6'
   *  RelationalOperator: '<S5>/Relational Operator'
   *  S-Function (sfix_bitop): '<S5>/Bitwise Operator'
   */
  if ((rtb_TmpSignalConversionAtMotAnd & ((uint8)BIT0MASK_CNT_U08)) == ((uint8)
       BIT0MASK_CNT_U08))
  {
    rtb_TmpSignalConversionAtMotA_1 = ((boolean)TRUE);
  }
  else
  {
    rtb_TmpSignalConversionAtMotA_1 = ((boolean)FALSE);
  }

  /* End of Switch: '<S5>/Switch' */

  /* Switch: '<S5>/Switch1' incorporates:
   *  Constant: '<S5>/Constant2'
   *  Constant: '<S5>/Constant3'
   *  Constant: '<S5>/Constant7'
   *  RelationalOperator: '<S5>/Relational Operator1'
   *  S-Function (sfix_bitop): '<S5>/Bitwise Operator1'
   */
  if ((rtb_TmpSignalConversionAtMotAnd & ((uint8)BIT1MASK_CNT_U08)) == ((uint8)
       BIT1MASK_CNT_U08))
  {
    rtb_TmpSignalConversionAtMotA_2 = ((boolean)TRUE);
  }
  else
  {
    rtb_TmpSignalConversionAtMotA_2 = ((boolean)FALSE);
  }

  /* End of Switch: '<S5>/Switch1' */

  /* If: '<S4>/If' incorporates:
   *  Constant: '<S4>/Constant'
   *  Constant: '<S4>/Constant1'
   *  Constant: '<S4>/Constant2'
   *  Inport: '<Root>/MotCurrDax'
   *  Inport: '<Root>/MotCurrDaxCmd'
   *  Inport: '<Root>/MotCurrQax'
   *  Inport: '<Root>/MotCurrQaxCmd'
   *  Logic: '<S4>/Logical Operator'
   *  RelationalOperator: '<S4>/Relational Operator'
   *  RelationalOperator: '<S4>/Relational Operator1'
   *  RelationalOperator: '<S4>/Relational Operator2'
   */
  if (((rtb_TmpSignalConversionAtMotA_0 == ((boolean)TRUE)) ||
       (rtb_TmpSignalConversionAtMotA_1 == ((boolean)TRUE))) ||
      (rtb_TmpSignalConversionAtMotA_2 == ((boolean)TRUE)))
  {
    Rte_Read_MotCurrQaxCmd_Val(&tmpRead_0);
    Rte_Read_MotCurrDaxCmd_Val(&tmpRead);

    /* Outputs for IfAction SubSystem: '<S4>/MotTqEstimdCalcnWithCmdInp' incorporates:
     *  ActionPort: '<S7>/Action Port'
     */
    /* Product: '<S7>/Product3' incorporates:
     *  Constant: '<S7>/Constant4'
     *  Constant: '<S7>/Constant5'
     *  Constant: '<S7>/Constant6'
     *  DataTypeConversion: '<S7>/Data Type Conversion3'
     *  Inport: '<Root>/MotCurrDaxCmd'
     *  Inport: '<Root>/MotCurrQaxCmd'
     *  Product: '<S7>/Product1'
     *  Product: '<S7>/Product2'
     *  Sum: '<S7>/Add'
     *  Sum: '<S7>/Add1'
     */
    rtb_Merge = ((((tmpRead * (rtb_TmpSignalConversionAtMotI_e -
      rtb_TmpSignalConversionAtMotInd)) * RELNCTQCON_ULS_F32) * ((float32)
      Rte_Prm_SysGlbPrmMotPoleCnt_Val())) + (rtb_TmpSignalConversionAtMotBac *
      ((float32)ARCHGLBPRM_HALFSQRT3_ULS_F32))) * tmpRead_0;

    /* End of Outputs for SubSystem: '<S4>/MotTqEstimdCalcnWithCmdInp' */
  }
  else
  {
    Rte_Read_MotCurrQax_Val(&tmpRead_0);
    Rte_Read_MotCurrDax_Val(&tmpRead);

    /* Outputs for IfAction SubSystem: '<S4>/MotTqEstimdCalcnWithMeasdInp' incorporates:
     *  ActionPort: '<S8>/Action Port'
     */
    /* Product: '<S8>/Product3' incorporates:
     *  Constant: '<S8>/Constant4'
     *  Constant: '<S8>/Constant5'
     *  Constant: '<S8>/Constant6'
     *  DataTypeConversion: '<S8>/Data Type Conversion3'
     *  Inport: '<Root>/MotCurrDax'
     *  Inport: '<Root>/MotCurrQax'
     *  Product: '<S8>/Product1'
     *  Product: '<S8>/Product2'
     *  Sum: '<S8>/Add'
     *  Sum: '<S8>/Add1'
     */
    rtb_Merge = ((((tmpRead * (rtb_TmpSignalConversionAtMotI_e -
      rtb_TmpSignalConversionAtMotInd)) * RELNCTQCON_ULS_F32) * ((float32)
      Rte_Prm_SysGlbPrmMotPoleCnt_Val())) + (rtb_TmpSignalConversionAtMotBac *
      ((float32)ARCHGLBPRM_HALFSQRT3_ULS_F32))) * tmpRead_0;

    /* End of Outputs for SubSystem: '<S4>/MotTqEstimdCalcnWithMeasdInp' */
  }

  /* End of If: '<S4>/If' */

  /* S-Function (Lim_f32): '<S6>/Lim_f32' incorporates:
   *  Constant: '<S6>/Constant'
   *  Constant: '<S6>/Constant1'
   *  Outport: '<Root>/MotTqEstimd'
   */
  tmpWrite = Lim_f32( (float32)rtb_Merge, (float32)MOTTQESTIMDMIN_MOTNWTMTR_F32,
                     (float32)MOTTQESTIMDMAX_MOTNWTMTR_F32);

  /* End of Outputs for RootInportFunctionCallGenerator: '<Root>/RootFcnCall_InsertedFor_call_MotTqCalcdPer1_at_outport_1' */

  /* Outport: '<Root>/MotTqEstimd' */
  (void) Rte_Write_MotTqEstimd_Val(tmpWrite);
}

/* Model initialize function */
FUNC(void, MotTqCalcd_CODE) MotTqCalcd_Init(void)
{
  /* (no initialization code required) */
}

#define MotTqCalcd_STOP_SEC_CODE
#include "MotTqCalcd_MemMap.h"

/*
 * File trailer for generated code.
 *
 * [EOF]
 */

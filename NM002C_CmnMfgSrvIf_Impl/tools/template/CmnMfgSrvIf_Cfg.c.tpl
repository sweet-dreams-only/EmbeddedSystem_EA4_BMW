/***********************************************************************************************************************
* Copyright ${year} Nxtr
* Nxtr Confidential
*
* Module File Name:   CmnMfgSrvIf_Cfg.c
* Module Description: Nxtr common manufacturing service interface to DCM
* Project           : CBD
* Author            : Jared Julien
************************************************************************************************************************
* Version Control:
* %version:          1 %
* %derived_by:       kzdyfh %
***********************************************************************************************************************/

/***********************************************************************************************************************
 * Include Statements
 **********************************************************************************************************************/
#include "Rte_CmnMfgSrvIf.h"
#include "Dcm.h"

/***********************************************************************************************************************
 * File Level Rule Deviations
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * Embedded Local Constants
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * Module Specific Variable Definitions
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * Local Function Prototype Definitions
 **********************************************************************************************************************/


/***********************************************************************************************************************
 * Function Definitions
 **********************************************************************************************************************/

#define CmnMfgSrvIf_START_SEC_CODE
#include "CmnMfgSrvIf_MemMap.h"

% for service in iocs + pids:
<% prefix = 'CmnMfgSrvIf_Srv0x%04X' % service.sid %>
% if service.read:
/***********************************************************************************************************************
 * Name        : ${prefix}Rd
 * Description : Service interface function invoked by DCM component when a 0x22 read has been requested that is linked
 *               to Nxtr service 0x${'%04X' % service.sid}.
 * Inputs      : OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
 * Outputs     : Data: Pointer to a buffer into which the service data shall be copied.
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Rd(Dcm_OpStatusType OpStatus, P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;

	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x22U,                     /* Service type will always be 0x22 for reads. */
			0xFFU,                     /* Sub-Function is not supported for this service type. */
			0x${'%04X' % service.sid}U,                   /* Service ID is fixed for this specific function. */
			Data,                      /* Pointer to the data buffer into which CMS will place the data. */
			0,                         /* Request length will always be zero for a read request. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated but ignored by DCM. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% if service.write:
/***********************************************************************************************************************
 * Name        : ${prefix}Wr
 * Description : Service interface function invoked by DCM component when a 0x2E write has been requested that is linked
 *               to Nxtr service 0x${'%04X' % service.sid}.
 * Inputs      : Data: Pointer to a buffer into which the service data shall be copied.
 *               OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Wr(
	P2CONST(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data,
	Dcm_OpStatusType OpStatus,
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;

	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x2EU,                     /* Service type will always be 0x2E for writes. */
			0xFFU,                     /* Sub-Function is not supported for this service type. */
			0x${'%04X' % service.sid}U,                   /* Service ID is fixed for this specific function. */
			(uint8*)Data,              /* Pointer to the data buffer from which CMS will read the data. */
			${service.bytes},                         /* Request length is specific to this service. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated with 0 but ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% if service.take:
/***********************************************************************************************************************
 * Name        : ${prefix}Adj
 * Description : Service interface function invoked by DCM component when a 0x2F 03 take control request is received
 *               that is linked to Nxtr service 0x${'%04X' % service.sid}.
 * Inputs      : Data: Pointer to a buffer into which the service data shall be used as input.
 *               OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Adj(
	P2CONST(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data,
	Dcm_OpStatusType OpStatus,
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;

	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x2FU,                     /* Service type will always be 0x2F for input/output control. */
			0x03U,                     /* Sub-Function will always be 3 for "short term adjust". */
			0x${'%04X' % service.sid}U,                   /* Service ID is fixed for this specific function. */
			(uint8*)Data,              /* Pointer to the data buffer from which CMS will read the data. */
			${service.bytes},                         /* Request length is specific to this service. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated with 0 but ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% if service.release:
/***********************************************************************************************************************
 * Name        : ${prefix}Rtn
 * Description : Service interface function invoked by DCM component when a 0x2F 00 return control request is received
 *               that is linked to Nxtr service 0x${'%04X' % service.sid}.
 * Inputs      : Data: Pointer to a buffer into which the service data shall be used as input.
 *               OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Rtn(
	Dcm_OpStatusType OpStatus,
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;

	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x2FU,                     /* Service type will always be 0x2F for input/output control. */
			0x00U,                     /* Sub-Function will always be 0 for "return control". */
			0x${'%04X' % service.sid}U,                   /* Service ID is fixed for this specific function. */
			NULL_PTR,                  /* Pointer to the data buffer from which CMS will read the data. */
			${service.bytes},                         /* Request length should always be zero. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated with 0 but ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;

% endfor;

% for routine in routines:
<% prefix = 'CmnMfgSrvIf_Srv0x%04X' % routine.sid %>
% if routine.start:
/***********************************************************************************************************************
 * Name        : ${prefix}Strt
 * Description : Service interface function invoked by DCM component when a 0x31 01 start routine request is received
 *               that is linked to Nxtr service 0x${'%04X' % routine.sid}.
 * Inputs      : OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
% if routine.start.in_bytes > 0:
 *               DcmDspStartRoutineInSignal: Pointer to buffer containing data input to routine.
% endif;
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
% if routine.start.out_bytes > 0:
 *               DcmDspStartRoutineOutSignal: Pointer to the buffer into which output data should be copied.
% endif;
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Strt(
% if routine.start.in_bytes > 0:
	P2CONST(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspStartRoutineInSignal,
% endif;
	Dcm_OpStatusType OpStatus,
% if routine.start.out_bytes > 0:
	P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspStartRoutineOutSignal,
% endif;
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;
	VAR(uint8, AUTOMATIC) InterBuf_Cnt_T_u08[${max(routine.start.in_bytes, routine.start.out_bytes, 1)}];
% if routine.start.in_bytes > 0 or routine.start.out_bytes > 0:
	VAR(uint16, AUTOMATIC) Idx_Cnt_T_u16;
% endif;

% if routine.start.in_bytes > 0:
	/* Copy input data over from input buffer into intermediate buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.start.in_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		InterBuf_Cnt_T_u08[Idx_Cnt_T_u16] = DcmDspStartRoutineInSignal[Idx_Cnt_T_u16];
	}
% endif;

	/* Invoke the service through the Main Function of NM001A. */
	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x31U,                     /* Service type will always be 0x31 for routine control. */
			0x01U,                     /* Sub-Function will always be 1 for "start". */
			0x${'%04X' % routine.sid}U,                   /* Service ID is fixed for this specific function. */
			InterBuf_Cnt_T_u08,        /* Pointer to the data buffer from which CMS will read the data. */
			${routine.start.in_bytes},                         /* Request length varies for each service. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated but be ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

% if routine.start.out_bytes > 0:
	/* Copy output data over to output data buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.start.out_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		DcmDspStartRoutineOutSignal[Idx_Cnt_T_u16] = InterBuf_Cnt_T_u08[Idx_Cnt_T_u16];
	}
% endif;

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% if routine.stop:
/***********************************************************************************************************************
 * Name        : ${prefix}Stop
 * Description : Service interface function invoked by DCM component when a 0x31 02 stop routine request is received
 *               that is linked to Nxtr service 0x${'%04X' % routine.sid}.
 * Inputs      : OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
% if routine.stop.in_bytes > 0:
 *               DcmDspRoutineStopInSignal: Pointer to buffer containing data input to routine.
% endif;
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
% if routine.stop.out_bytes > 0:
 *               DcmDspRoutineStopOutSignal: Pointer to the buffer into which output data should be copied.
% endif;
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Stop(
% if routine.stop.in_bytes > 0:
	P2CONST(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspRoutineStopInSignal,
% endif;
	Dcm_OpStatusType OpStatus,
% if routine.stop.out_bytes > 0:
	P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspRoutineStopOutSignal,
% endif;
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;
	VAR(uint8, AUTOMATIC) InterBuf_Cnt_T_u08[${max(routine.stop.in_bytes, routine.stop.out_bytes, 1)}];
% if routine.stop.in_bytes > 0 or routine.stop.out_bytes > 0:
	VAR(uint16, AUTOMATIC) Idx_Cnt_T_u16;
% endif;

% if routine.stop.in_bytes > 0:
	/* Copy input data over from input buffer into intermediate buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.stop.in_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		InterBuf_Cnt_T_u08[Idx_Cnt_T_u16] = DcmDspRoutineStopInSignal[Idx_Cnt_T_u16];
	}
% endif;

	/* Invoke the service through the Main Function of NM001A. */
	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x31U,                     /* Service type will always be 0x31 for routine control. */
			0x02U,                     /* Sub-Function will always be 2 for "stop". */
			0x${'%04X' % routine.sid}U,                   /* Service ID is fixed for this specific function. */
			InterBuf_Cnt_T_u08,        /* Pointer to the data buffer from which CMS will read the data. */
			${routine.stop.in_bytes},                         /* Request length varies for each service. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated but be ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

% if routine.stop.out_bytes > 0:
	/* Copy output data over to output data buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.stop.out_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		DcmDspRoutineStopOutSignal[Idx_Cnt_T_u16] = InterBuf_Cnt_T_u08[Idx_Cnt_T_u16];
	}
% endif;

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% if routine.result:
/***********************************************************************************************************************
 * Name        : ${prefix}Sts
 * Description : Service interface function invoked by DCM component when a 0x31 03 request results routine request is
 *                received that is linked to Nxtr service 0x${'%04X' % routine.sid}.
 * Inputs      : OpStatus: Indicates information about this function call - Nxtr doesn't use this feature for CMS.
% if routine.result.in_bytes > 0:
 *               DcmDspRoutineRequestResInSignal: Pointer to buffer containing data input to routine.
% endif;
 * Outputs     : ErrorCode: Indicates a specific UDS error code regarding the reason for failure.
% if routine.result.out_bytes > 0:
 *               DcmDspRoutineRequestResOutSignal: Pointer to the buffer into which output data should be copied.
% endif;
 * Return      : E_OK upon success, E_NOT_OK upon failure.
 * Usage Notes : Function is automatically configured by NM002C to be called by DCM.  This function is not expected to
 *               be used as part of a public API to any other components.  This is the reason why the function is not
 *               externed (prototype/extern statements are automatically generated by DCM for it's use).
 **********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) ${prefix}Sts(
% if routine.result.in_bytes > 0:
	P2CONST(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspRoutineRequestResInSignal,
% endif;
	Dcm_OpStatusType OpStatus,
% if routine.result.out_bytes > 0:
	P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) DcmDspRoutineRequestResOutSignal,
% endif;
	P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, DCM_VAR_NOINIT) ErrorCode)
{
	VAR(uint16, AUTOMATIC) RespLen_Cnt_T_u16 = 0;
	VAR(uint8, AUTOMATIC) RespCod_Cnt_T_u08 = 0;
	VAR(uint8, AUTOMATIC) InterBuf_Cnt_T_u08[${max(routine.result.in_bytes, routine.result.out_bytes, 1)}];
% if routine.result.in_bytes > 0 or routine.result.out_bytes > 0:
	VAR(uint16, AUTOMATIC) Idx_Cnt_T_u16;
% endif;

% if routine.result.in_bytes > 0:
	/* Copy input data over from input buffer into intermediate buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.result.in_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		InterBuf_Cnt_T_u08[Idx_Cnt_T_u16] = DcmDspRoutineRequestResInSignal[Idx_Cnt_T_u16];
	}
% endif;

	/* Invoke the service through the Main Function of NM001A. */
	(void)Rte_Call_CmnMfgSrvCmnMfgSrvMaiFct_Oper(
			0x31U,                     /* Service type will always be 0x31 for routine control. */
			0x03U,                     /* Sub-Function will always be 3 for "request results". */
			0x${'%04X' % routine.sid}U,                   /* Service ID is fixed for this specific function. */
			InterBuf_Cnt_T_u08,        /* Pointer to the data buffer from which CMS will read the data. */
			${routine.result.in_bytes},                         /* Request length varies for each service. */
			&RespLen_Cnt_T_u16,        /* Response length will be populated but be ignored by DCM anyways. */
			&RespCod_Cnt_T_u08         /* Response code indicates an error of some type when non-zero. */
	);

% if routine.result.out_bytes > 0:
	/* Copy output data over to output data buffer. */
	for (Idx_Cnt_T_u16 = 0U; Idx_Cnt_T_u16 < ${routine.result.out_bytes}U; Idx_Cnt_T_u16 += 1U)
	{
		DcmDspRoutineRequestResOutSignal[Idx_Cnt_T_u16] = InterBuf_Cnt_T_u08[Idx_Cnt_T_u16];
	}
% endif;

	*ErrorCode = (Dcm_NegativeResponseCodeType)RespCod_Cnt_T_u08;

	return (RespCod_Cnt_T_u08 == E_OK) ? E_OK : E_NOT_OK;
}
% endif;
% endfor;

#define CmnMfgSrvIf_STOP_SEC_CODE
#include "CmnMfgSrvIf_MemMap.h"
